functional overview:

   ______________________________________________________________________________________
<<Description_______Description_______Description_______Description_______Description_____>>

struct s_map ->
->  структура временного хранения путей до файлов-источников (char *); временного хранения
    цветов(int *); постоянного хранения карты (char **)

struct s_data ->
->  структура постоянного хранения mlx-данных:
        -mlx;
        -win;
        -изображения-источники, после их преобразования через mlx_xpm_file_to_image;
        -высоту/ширину для изображений;
        -в перспективе, цвета пола и потолка;

struct s_gen ->
->  генеральная структура, хранящая в себе:
        -файловый дескриптор координирующего файла;
        -t_map;
        -t_data;
        -позицию изгока по X и Y, а так же его тип (сторону в которую повёрнут, S, N, E, W)
   ______________________________________________________________________________________
<<REUSABLE_FNCS_____REUSABLE_FNCS______REUSABLE_FNCS______REUSABLE_FNCS______REUSABLE_FNCS>>

int		noonsym(char *str, char sym); ->
->  проверяет наличие в строке не единственного символа, если символ единственный, возвращает единицу,
    если имеются ещё какие-то символы, возвращает ноль. Принимает строго имеющуюся строку (не проверяет
    на пустоту строки) и символ, который нужно проверить на наличие не только его в строке.

int		duarrlen(char **array); ->
->  функция аналогичная strlen, проверяет количество строк в двумерном массиве.

char	**duarrfree(char **arr); ->
->  производит очистку двумерного массива при помощи free.

char	**duarrcalloc(int size); ->
->  производит malloc под size строк и заполняет их NULL.

char	**duarrotate(char **duarr); ->
->  возвращает "повёрнутый" двумерный массив, делая его строки столбцами, как str1[y][x] = str2[x][y].
    Обязательное условие, чтобы все строки массива были одинаковой длины.

char	**stradd(char *str, char **dst); ->
->  добавление строки str в строку dst

int 	sne_noonsym(char *str, char sym); ->
->  проверяет, что в начале и в конце строки str находится один единственный символ sym.

int 	nohavesm(char *str, char sym); ->
->  проверка наличия в строке str наличия символа sym.

int 	str_no_have_syms(char *str, char *syms); ->
->  проверка наличия в строке str наличия хотябы одного из символов из syms.

int 	onsymofstr(char *str, const char *symbols); ->
->  проверка количества появлений символов из symbols в строке str.

int 	getsympos(char *str, const char *symbols); ->
->  возвращает положение первого найденного из символов, имеющихся в строке symbols в строке str.

char	get_first_found_symbol(char const *str, char const *symbols); ->
->   возвращает первый найденный в строке str символ из имеющихся в строке symbols.

char	fstsym(char *str); ->
->   поиск первого нетабуляционного символа в строке str.

   ______________________________________________________________________________________
<<__NOT_REUSABLE_FNCS___________NOT_REUSABLE_FNCS________________NOT_REUSABLE_FNCS________>>

void    error_call(char *message, int exit_code, t_gen **gen) ->
->  освобождает занимаемое нашими структурами пространство, выводит сообщение, переданное в message,
    заканчивает выполнение программы с кодом exit_code.

int		is_valid_name(char *name); ->
->  проеряет валидность имени, переданного в агрументе на наличие разширения ".cub".

int		get_map(t_map **mpsrc, int map_file); ->
->  Принимая структуру для данных карты и файловый дескриптор файла-кординатора, функция с помощью
    get_next_line построчно считывает файл параллельно проверяя корректность считывания с файла,
    пока не встретит начало карты, фиксирует данные (пути до файлов-источников, требуемые цвета)
    во временное хранение, как только встречает первый символ, принадлежащий карте (0 или 1),
    всё остальное записывает в двумерный массив карты. Перед выходом, проверяет валидность
    полученных путей до файлов-источников посредством их поочерёдного открытия и закрытия.

int 	get_color(char *src, int **color_dst); ->
->  принимает строку-источник и двумерный массив в который будет производиться запись временных данных
    цвета в положениях: color_dst[0][0] - R, color_dst[0][1] - G, color_dst[0][2] - B.

int		valid_src_file(char *file_name, int *file_fd); ->
->  проверка валидности файла-источника. Использует is_valid_name для проверки корректности имени файла
    (наличия расширения .cub), после чего проверяет его доступность посредством открытия с помощью open.

int		valid_map_data(t_map **map_source); ->
->  проверяет валидность полученных путей до файлов-источников посредством их поочерёдного открытия
    и закрытия, в случае некорректности файла, возвращает wrongcloser.

int		wrongcloser(int tmpfd); ->
->  закрывает полученный файловый дескриптор и возвращает 0.

void	init_fnc(t_gen **gen); ->
->  аллоцирует пространство под структуры и зануляет все параметры внутри используемых в проекте структур.

int		get_color_ret(int const *color_dst); ->
->  проверяет корректность полученных в структуру числа (чтобы оно было в пределе от 0 до 255).

int		wrong_pos(char **map, int y); ->
->  проверка валидности положеня символов: 0 должен быть строго окружён 0,1,S,N,E,W символами,
    иначе - невалидно, то же самое качается unit-символа, пробелы и единици просто пропускаются.

int		valid_map(t_gen **gen); ->
->  ведёт валидацию карты, проверяет, чтобы не находилось больше 1 юнита на карте, проводит проверку
    wrong_pos-ером, отсутствие пустых строк, соответствие длин всех строк и наличие разрывов.

int		add_content_to_map_srcs(char *line, t_map **dst); ->
->  выявление в line идентификаторов пути до файла и сохранение этого пути в соответствующий раздел
    структуры временного хранения

int		get_path(char *src, char **dst); ->
->  взятие из строки пути, учитываются isalnum, '/', '_', '.' иные символы сообщают о конце текста пути.



int		data_transform(t_gen **gen); ->
->  ||НЕЗАКОНЧЕННАЯ ФУНКЦИЯ|| в планах, должна иницилизировать mlx, получать изображения из файлов-
    -источников, класть их в структуру, проверять валидность данных карты.